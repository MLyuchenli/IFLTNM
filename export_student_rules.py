import argparse
from pathlib import Path
from typing import List, Tuple

import torch


def _term_from_center(val: float) -> str:
    # map a value in [0,1] to nearest {0,0.25,0.5,0.75,1}
    grid = [0.0, 0.25, 0.5, 0.75, 1.0]
    terms = ["VL", "L", "M", "H", "VH"]
    idx = min(range(len(grid)), key=lambda i: abs(val - grid[i]))
    return terms[idx]


def _topk_abs(vec: torch.Tensor, k: int) -> List[Tuple[int, float]]:
    # vec: (D,)
    k = min(k, vec.numel())
    vals, idx = torch.topk(vec.abs(), k)
    return [(int(i.item()), float(vec[i].item())) for i in idx]


def export_student_rules(
    ckpt_path: str,
    manifest_path: str,
    out_path: str,
    use_feature_names: bool,
    precision: int,
    top_terms: int,
    max_ante_dim: int,
) -> None:
    ckpt = torch.load(ckpt_path, map_location="cpu")
    W = ckpt["W"].float()        # (R,C,D)
    b = ckpt["b"].float()        # (R,C)
    centers = ckpt["rule_centers"].float()  # (R,D)

    manifest = torch.load(manifest_path, map_location="cpu")
    feature_names = manifest.get("feature_names", None)

    R, C, D = W.shape

    if not use_feature_names or not isinstance(feature_names, list) or len(feature_names) != D:
        feat = [f"x_{d+1}" for d in range(D)]
    else:
        # LaTeX-safe: wrap in \mathrm{}
        feat = [str(n) for n in feature_names]

    lines = []
    lines.append(r"% Auto-generated by export_student_rules.py")
    lines.append(r"% Student ckpt: " + str(Path(ckpt_path).as_posix()))
    lines.append(r"\begin{tabular}{ll}")

    for k in range(R):
        # antecedent: choose dims by |center-0.5|
        score = (centers[k] - 0.5).abs()
        m = min(max_ante_dim, D)
        dims = torch.topk(score, m).indices.tolist()

        ante_parts = []
        for d in dims:
            name = feat[d]
            term = _term_from_center(float(centers[k, d].item()))
            ante_parts.append(rf"\mathrm{{{name}}}~is~{term}")
        ante = r" \wedge ".join(ante_parts) if ante_parts else r"\top"

        lines.append(rf"{k+1} & IF~{ante}\\")

        # consequents for all classes
        lines.append(r"& THEN $\begin{aligned}")
        for c in range(C):
            terms = _topk_abs(W[k, c], top_terms)
            # build f_{k,c}(x)
            rhs = f"{b[k,c].item():.{precision}f}"
            for d, w in terms:
                sign = "+" if w >= 0 else "-"
                rhs += f" {sign} {abs(w):.{precision}f}\\mathrm{{{feat[d]}}}"
            lines.append(rf"f_{{{k+1},{c+1}}}(\mathbf{{x}}) &= {rhs} \\")
        lines.append(r"\end{aligned}$\\[2pt]")

    lines.append(r"\end{tabular}")

    Path(out_path).write_text("\n".join(lines), encoding="utf-8")


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--student_ckpt", type=str, required=True)
    ap.add_argument("--manifest", type=str, required=True)
    ap.add_argument("--out", type=str, required=True)
    ap.add_argument("--use_feature_names", action="store_true")
    ap.add_argument("--precision", type=int, default=2)
    ap.add_argument("--top_terms", type=int, default=8)
    ap.add_argument("--max_ante_dim", type=int, default=8)
    args = ap.parse_args()

    export_student_rules(
        ckpt_path=args.student_ckpt,
        manifest_path=args.manifest,
        out_path=args.out,
        use_feature_names=args.use_feature_names,
        precision=args.precision,
        top_terms=args.top_terms,
        max_ante_dim=args.max_ante_dim,
    )


if __name__ == "__main__":
    main()
